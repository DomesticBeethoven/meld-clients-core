"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _immutabilityHelper = _interopRequireDefault(require("immutability-helper"));

var _jsum = _interopRequireDefault(require("jsum"));

var _index = require("../actions/index");

var _meldActions = require("../actions/meldActions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var INIT_STATE = {
  //    graph: {  
  //        annoGraph: {}, 
  //        targetsById: {}, 
  //        targetsByType: {}
  //    },
  etags: {},
  nextSession: "",
  info: {},
  graph: [],
  graphDocs: [],
  objectives: [],
  outcomes: [],
  outcomesHash: "",
  allObjectivesApplied: false
};

function _default() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INIT_STATE;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _index.FETCH_GRAPH:
      var byId = {};
      var byType = {};
      var payload = action.payload;

      if (typeof payload === "string") {
        payload = JSON.parse(payload);
      }

      payload = (0, _index.ensureArray)(payload, "@graph");
      payload = payload["@graph"][0];

      if ("ldp:contains" in payload) {
        payload = (0, _index.ensureArray)(payload, "ldp:contains");
        payload["ldp:contains"].map(function (a) {
          if ("meld:state" in a && a["meld:state"]["@id"] == "meld:processed") {
            // Decide whether we want to render the processed annotation
            // ... and modify its motivation if necessary to signal its new purpose
            // This is required for annotations that both have renderings (should always show)
            // and side effects (should only happen once)
            if (a["oa:motivatedBy"]["@id"] === "motivation:muzicodeTriggered") {
              a["oa:motivatedBy"]["@id"] = "motivation:archivedMuzicodeTrigger";
              delete a["meld:state"];
            } else {
              // We can skip this processed annotation
              return;
            }
          }

          a = (0, _index.ensureArray)(a, "oa:hasTarget");
          a["oa:hasTarget"].map(function (targetResource) {
            // lookup target IDs to get types and component annotations
            if (targetResource["@id"] in byId) {
              byId[targetResource["@id"]]["annotations"].push(a);
            } else {
              byId[targetResource["@id"]] = {
                "type": targetResource["@type"],
                "annotations": [a]
              };
            } // lookup target type to get target ID


            if (targetResource["@type"] in byType) {
              byType[targetResource["@type"]].push(_defineProperty({}, targetResource["@id"], true));
            } else {
              byType[targetResource["@type"]] = [_defineProperty({}, targetResource["@id"], true)];
            }
          });
        });
      } else {
        console.log("Graph contains no annotations: ", payload);
      }

      return (0, _immutabilityHelper["default"])(state, {
        annoGraph: {
          $set: payload
        },
        targetsById: {
          $set: byId
        },
        targetsByType: {
          $set: byType
        }
      });

    case _index.SESSION_GRAPH_ETAG:
      return (0, _immutabilityHelper["default"])(state, {
        etags: {
          $set: _defineProperty({}, action.payload.uri, action.payload.etag)
        }
      });

    case _meldActions.QUEUE_NEXT_SESSION:
      // console.log("Setting next session: ", action.payload);
      return (0, _immutabilityHelper["default"])(state, {
        nextSession: {
          $set: action.payload
        }
      });

    case _index.FETCH_WORK:
      if (action.payload.info) {
        return (0, _immutabilityHelper["default"])(state, {
          info: {
            $merge: _defineProperty({}, action.payload.target["@id"], action.payload.info)
          }
        });
      }

      break;

    case _index.SET_TRAVERSAL_OBJECTIVES:
      // register the set of objectives provided by the MELD application
      // and initialise the outcomes in a corresponding array.
      // Typically run once on mount.
      return (0, _immutabilityHelper["default"])(state, {
        objectives: {
          $set: action.payload
        },
        outcomes: {
          $set: new Array(action.payload.length)
        }
      });

    case _index.FETCH_GRAPH_DOCUMENT:
      // new graph fragment has arrived. If we don't have it from a previous traversal, add it to our graph.
      if (!state.graphDocs.includes(action.payload.uri)) {
        // console.log(state.graph, state.graphDocs, action)
        return (0, _immutabilityHelper["default"])(state, {
          graph: {
            $push: action.payload.data
          },
          graphDocs: {
            $push: [action.payload.uri]
          }
        });
      } else {//console.log("FETCH_GRAPH_DOCUMENT: ignoring as already seen: ", action.payload.uri);
      }

      break;

    case _index.APPLY_TRAVERSAL_OBJECTIVE:
      // an objective has been applied against the graph. Store the outcome at the
      // appropriate index.
      var updatedOutcomes = state.outcomes;
      updatedOutcomes[action.payload.ix] = action.payload.framed;

      var updatedOutcomesHash = _jsum["default"].digest(updatedOutcomes, 'md5', 'hex');

      if (action.payload.ix === state.objectives.length - 1) {
        console.log("About to switch on allObjectivesApplied with", updatedOutcomes, state);
      }

      return (0, _immutabilityHelper["default"])(state, {
        outcomes: {
          $set: updatedOutcomes
        },
        outcomesHash: {
          $set: updatedOutcomesHash
        },
        allObjectivesApplied: {
          $set: action.payload.ix === state.objectives.length - 1 ? true : false
        }
      });

    default:
      return state;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9yZWR1Y2VyX2dyYXBoLmpzIl0sIm5hbWVzIjpbIklOSVRfU1RBVEUiLCJldGFncyIsIm5leHRTZXNzaW9uIiwiaW5mbyIsImdyYXBoIiwiZ3JhcGhEb2NzIiwib2JqZWN0aXZlcyIsIm91dGNvbWVzIiwib3V0Y29tZXNIYXNoIiwiYWxsT2JqZWN0aXZlc0FwcGxpZWQiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJGRVRDSF9HUkFQSCIsImJ5SWQiLCJieVR5cGUiLCJwYXlsb2FkIiwiSlNPTiIsInBhcnNlIiwibWFwIiwiYSIsInRhcmdldFJlc291cmNlIiwicHVzaCIsImNvbnNvbGUiLCJsb2ciLCJhbm5vR3JhcGgiLCIkc2V0IiwidGFyZ2V0c0J5SWQiLCJ0YXJnZXRzQnlUeXBlIiwiU0VTU0lPTl9HUkFQSF9FVEFHIiwidXJpIiwiZXRhZyIsIlFVRVVFX05FWFRfU0VTU0lPTiIsIkZFVENIX1dPUksiLCIkbWVyZ2UiLCJ0YXJnZXQiLCJTRVRfVFJBVkVSU0FMX09CSkVDVElWRVMiLCJBcnJheSIsImxlbmd0aCIsIkZFVENIX0dSQVBIX0RPQ1VNRU5UIiwiaW5jbHVkZXMiLCIkcHVzaCIsImRhdGEiLCJBUFBMWV9UUkFWRVJTQUxfT0JKRUNUSVZFIiwidXBkYXRlZE91dGNvbWVzIiwiaXgiLCJmcmFtZWQiLCJ1cGRhdGVkT3V0Y29tZXNIYXNoIiwiSlN1bSIsImRpZ2VzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFDQSxJQUFNQSxVQUFVLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxFQUFBQSxLQUFLLEVBQUUsRUFOVTtBQU9qQkMsRUFBQUEsV0FBVyxFQUFFLEVBUEk7QUFRakJDLEVBQUFBLElBQUksRUFBRSxFQVJXO0FBU2pCQyxFQUFBQSxLQUFLLEVBQUUsRUFUVTtBQVVqQkMsRUFBQUEsU0FBUyxFQUFFLEVBVk07QUFXakJDLEVBQUFBLFVB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QUksRUFBRWtCO0FBREUsU0FEUztBQUluQnBDLFFBQUFBLFlBQVksRUFBRTtBQUNaa0IsVUFBQUEsSUFBSSxFQUFFcUI7QUFETSxTQUpLO0FBT25CdEMsUUFBQUEsb0JBQW9CLEVBQUU7QUFDcEJpQixVQUFBQSxJQUFJLEVBQUVmLE1BQU0sQ0FBQ0ssT0FBUCxDQUFlNkIsRUFBZixLQUFzQm5DLEtBQUssQ0FBQ0osVUFBTixDQUFpQmdDLE1BQWpCLEdBQXdCLENBQTlDLEdBQWtELElBQWxELEdBQXlEO0FBRDNDO0FBUEgsT0FBZCxDQUFQOztBQVlGO0FBQ0UsYUFBTzVCLEtBQVA7QUExSko7QUE0SkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXBkYXRlIGZyb20gJ2ltbXV0YWJpbGl0eS1oZWxwZXInO1xuaW1wb3J0IEpTdW0gZnJvbSAnanN1bSc7XG5pbXBvcnQgeyBBUFBMWV9UUkFWRVJTQUxfT0JKRUNUSVZFLCBlbnN1cmVBcnJheSwgRkVUQ0hfR1JBUEgsIEZFVENIX0dSQVBIX0RPQ1VNRU5ULCBGRVRDSF9XT1JLLCBTRVNTSU9OX0dSQVBIX0VUQUcsIFNFVF9UUkFWRVJTQUxfT0JKRUNUSVZFUyB9IGZyb20gJy4uL2FjdGlvbnMvaW5kZXgnO1xuaW1wb3J0IHsgUVVFVUVfTkVYVF9TRVNTSU9OIH0gZnJvbSAnLi4vYWN0aW9ucy9tZWxkQWN0aW9ucyc7XG5jb25zdCBJTklUX1NUQVRFID0ge1xuICAvLyAgICBncmFwaDogeyAgXG4gIC8vICAgICAgICBhbm5vR3JhcGg6IHt9LCBcbiAgLy8gICAgICAgIHRhcmdldHNCeUlkOiB7fSwgXG4gIC8vICAgICAgICB0YXJnZXRzQnlUeXBlOiB7fVxuICAvLyAgICB9LFxuICBldGFnczoge30sXG4gIG5leHRTZXNzaW9uOiBcIlwiLFxuICBpbmZvOiB7fSxcbiAgZ3JhcGg6IFtdLFxuICBncmFwaERvY3M6IFtdLFxuICBvYmplY3RpdmVzOiBbXSxcbiAgb3V0Y29tZXM6IFtdLFxuICBvdXRjb21lc0hhc2g6IFwiXCIsXG4gIGFsbE9iamVjdGl2ZXNBcHBsaWVkOiBmYWxzZVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGF0ZSA9IElOSVRfU1RBVEUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBGRVRDSF9HUkFQSDpcbiAgICAgIGxldCBieUlkID0ge307XG4gICAgICBsZXQgYnlUeXBlID0ge307XG4gICAgICBsZXQgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICB9IFxuXG5cbiAgICAgIHBheWxvYWQgPSBlbnN1cmVBcnJheShwYXlsb2FkLCBcIkBncmFwaFwiKTsgXG5cbiAgICAgIHBheWxvYWQgPSBwYXlsb2FkW1wiQGdyYXBoXCJdWzBdO1xuXG4gICAgICBpZiAoXCJsZHA6Y29udGFpbnNcIiBpbiBwYXlsb2FkKSB7XG4gICAgICAgIHBheWxvYWQgPSBlbnN1cmVBcnJheShwYXlsb2FkLCBcImxkcDpjb250YWluc1wiKTtcbiAgICAgICAgcGF5bG9hZFtcImxkcDpjb250YWluc1wiXS5tYXAoYSA9PiB7XG4gICAgICAgICAgaWYgKFwibWVsZDpzdGF0ZVwiIGluIGEgJiYgYVtcIm1lbGQ6c3RhdGVcIl1bXCJAaWRcIl0gPT0gXCJtZWxkOnByb2Nlc3NlZFwiKSB7XG4gICAgICAgICAgICAvLyBEZWNpZGUgd2hldGhlciB3ZSB3YW50IHRvIHJlbmRlciB0aGUgcHJvY2Vzc2VkIGFubm90YXRpb25cbiAgICAgICAgICAgIC8vIC4uLiBhbmQgbW9kaWZ5IGl0cyBtb3RpdmF0aW9uIGlmIG5lY2Vzc2FyeSB0byBzaWduYWwgaXRzIG5ldyBwdXJwb3NlXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGZvciBhbm5vdGF0aW9ucyB0aGF0IGJvdGggaGF2ZSByZW5kZXJpbmdzIChzaG91bGQgYWx3YXlzIHNob3cpXG4gICAgICAgICAgICAvLyBhbmQgc2lkZSBlZmZlY3RzIChzaG91bGQgb25seSBoYXBwZW4gb25jZSlcbiAgICAgICAgICAgIGlmIChhW1wib2E6bW90aXZhdGVkQnlcIl1bXCJAaWRcIl0gPT09IFwibW90aXZhdGlvbjptdXppY29kZVRyaWdnZXJlZFwiKSB7XG4gICAgICAgICAgICAgIGFbXCJvYTptb3RpdmF0ZWRCeVwiXVtcIkBpZFwiXSA9IFwibW90aXZhdGlvbjphcmNoaXZlZE11emljb2RlVHJpZ2dlclwiO1xuICAgICAgICAgICAgICBkZWxldGUgYVtcIm1lbGQ6c3RhdGVcIl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBjYW4gc2tpcCB0aGlzIHByb2Nlc3NlZCBhbm5vdGF0aW9uXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gZW5zdXJlQXJyYXkoYSwgXCJvYTpoYXNUYXJnZXRcIik7XG4gICAgICAgICAgYVtcIm9hOmhhc1RhcmdldFwiXS5tYXAodGFyZ2V0UmVzb3VyY2UgPT4ge1xuICAgICAgICAgICAgLy8gbG9va3VwIHRhcmdldCBJRHMgdG8gZ2V0IHR5cGVzIGFuZCBjb21wb25lbnQgYW5ub3RhdGlvbnNcbiAgICAgICAgICAgIGlmICh0YXJnZXRSZXNvdXJjZVtcIkBpZFwiXSBpbiBieUlkKSB7XG4gICAgICAgICAgICAgIGJ5SWRbdGFyZ2V0UmVzb3VyY2VbXCJAaWRcIl1dW1wiYW5ub3RhdGlvbnNcIl0ucHVzaChhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJ5SWRbdGFyZ2V0UmVzb3VyY2VbXCJAaWRcIl1dID0ge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiB0YXJnZXRSZXNvdXJjZVtcIkB0eXBlXCJdLFxuICAgICAgICAgICAgICAgIFwiYW5ub3RhdGlvbnNcIjogW2FdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IC8vIGxvb2t1cCB0YXJnZXQgdHlwZSB0byBnZXQgdGFyZ2V0IElEXG5cblxuICAgICAgICAgICAgaWYgKHRhcmdldFJlc291cmNlW1wiQHR5cGVcIl0gaW4gYnlUeXBlKSB7XG4gICAgICAgICAgICAgIGJ5VHlwZVt0YXJnZXRSZXNvdXJjZVtcIkB0eXBlXCJdXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBbdGFyZ2V0UmVzb3VyY2VbXCJAaWRcIl1dOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnlUeXBlW3RhcmdldFJlc291cmNlW1wiQHR5cGVcIl1dID0gW3tcbiAgICAgICAgICAgICAgICBbdGFyZ2V0UmVzb3VyY2VbXCJAaWRcIl1dOiB0cnVlXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggY29udGFpbnMgbm8gYW5ub3RhdGlvbnM6IFwiLCBwYXlsb2FkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZShzdGF0ZSwge1xuICAgICAgICBhbm5vR3JhcGg6IHtcbiAgICAgICAgICAkc2V0OiBwYXlsb2FkXG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldHNCeUlkOiB7XG4gICAgICAgICAgJHNldDogYnlJZFxuICAgICAgICB9LFxuICAgICAgICB0YXJnZXRzQnlUeXBlOiB7XG4gICAgICAgICAgJHNldDogYnlUeXBlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY2FzZSBTRVNTSU9OX0dSQVBIX0VUQUc6XG4gICAgICByZXR1cm4gdXBkYXRlKHN0YXRlLCB7XG4gICAgICAgIGV0YWdzOiB7XG4gICAgICAgICAgJHNldDoge1xuICAgICAgICAgICAgW2FjdGlvbi5wYXlsb2FkLnVyaV06IGFjdGlvbi5wYXlsb2FkLmV0YWdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY2FzZSBRVUVVRV9ORVhUX1NFU1NJT046XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlNldHRpbmcgbmV4dCBzZXNzaW9uOiBcIiwgYWN0aW9uLnBheWxvYWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZShzdGF0ZSwge1xuICAgICAgICBuZXh0U2Vzc2lvbjoge1xuICAgICAgICAgICRzZXQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY2FzZSBGRVRDSF9XT1JLOlxuICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkLmluZm8pIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZShzdGF0ZSwge1xuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICRtZXJnZToge1xuICAgICAgICAgICAgICBbYWN0aW9uLnBheWxvYWQudGFyZ2V0W1wiQGlkXCJdXTogYWN0aW9uLnBheWxvYWQuaW5mb1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTRVRfVFJBVkVSU0FMX09CSkVDVElWRVM6XG4gICAgICAvLyByZWdpc3RlciB0aGUgc2V0IG9mIG9iamVjdGl2ZXMgcHJvdmlkZWQgYnkgdGhlIE1FTEQgYXBwbGljYXRpb25cbiAgICAgIC8vIGFuZCBpbml0aWFsaXNlIHRoZSBvdXRjb21lcyBpbiBhIGNvcnJlc3BvbmRpbmcgYXJyYXkuXG4gICAgICAvLyBUeXBpY2FsbHkgcnVuIG9uY2Ugb24gbW91bnQuXG4gICAgICByZXR1cm4gdXBkYXRlKHN0YXRlLCB7XG4gICAgICAgIG9iamVjdGl2ZXM6IHtcbiAgICAgICAgICAkc2V0OiBhY3Rpb24ucGF5bG9hZFxuICAgICAgICB9LFxuICAgICAgICBvdXRjb21lczoge1xuICAgICAgICAgICRzZXQ6IG5ldyBBcnJheShhY3Rpb24ucGF5bG9hZC5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY2FzZSBGRVRDSF9HUkFQSF9ET0NVTUVOVDpcbiAgICAgIC8vIG5ldyBncmFwaCBmcmFnbWVudCBoYXMgYXJyaXZlZC4gSWYgd2UgZG9uJ3QgaGF2ZSBpdCBmcm9tIGEgcHJldmlvdXMgdHJhdmVyc2FsLCBhZGQgaXQgdG8gb3VyIGdyYXBoLlxuICAgICAgaWYoIXN0YXRlLmdyYXBoRG9jcy5pbmNsdWRlcyhhY3Rpb24ucGF5bG9hZC51cmkpKSB7IFxuICAgICAgIC8vIGNvbnNvbGUubG9nKHN0YXRlLmdyYXBoLCBzdGF0ZS5ncmFwaERvY3MsIGFjdGlvbilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZShzdGF0ZSwge1xuICAgICAgICAgIGdyYXBoOiB7XG4gICAgICAgICAgICAkcHVzaDogYWN0aW9uLnBheWxvYWQuZGF0YSBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdyYXBoRG9jczogeyBcbiAgICAgICAgICAgICRwdXNoOiBbYWN0aW9uLnBheWxvYWQudXJpXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgeyBcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZFVENIX0dSQVBIX0RPQ1VNRU5UOiBpZ25vcmluZyBhcyBhbHJlYWR5IHNlZW46IFwiLCBhY3Rpb24ucGF5bG9hZC51cmkpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFQUExZX1RSQVZFUlNBTF9PQkpFQ1RJVkU6XG4gICAgICAvLyBhbiBvYmplY3RpdmUgaGFzIGJlZW4gYXBwbGllZCBhZ2FpbnN0IHRoZSBncmFwaC4gU3RvcmUgdGhlIG91dGNvbWUgYXQgdGhlXG4gICAgICAvLyBhcHByb3ByaWF0ZSBpbmRleC5cbiAgICAgIGxldCB1cGRhdGVkT3V0Y29tZXMgPSBzdGF0ZS5vdXRjb21lcztcbiAgICAgIHVwZGF0ZWRPdXRjb21lc1thY3Rpb24ucGF5bG9hZC5peF0gPSBhY3Rpb24ucGF5bG9hZC5mcmFtZWQ7XG4gICAgICBsZXQgdXBkYXRlZE91dGNvbWVzSGFzaCA9IEpTdW0uZGlnZXN0KHVwZGF0ZWRPdXRjb21lcywgJ21kNScsICdoZXgnKTtcbiAgICAgIGlmKGFjdGlvbi5wYXlsb2FkLml4ID09PSBzdGF0ZS5vYmplY3RpdmVzLmxlbmd0aC0xKSB7IFxuICAgICAgICBjb25zb2xlLmxvZyhcIkFib3V0IHRvIHN3aXRjaCBvbiBhbGxPYmplY3RpdmVzQXBwbGllZCB3aXRoXCIsIHVwZGF0ZWRPdXRjb21lcywgc3RhdGUpXG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlKHN0YXRlLCB7XG4gICAgICAgIG91dGNvbWVzOiB7XG4gICAgICAgICAgJHNldDogdXBkYXRlZE91dGNvbWVzXG4gICAgICAgIH0sXG4gICAgICAgIG91dGNvbWVzSGFzaDoge1xuICAgICAgICAgICRzZXQ6IHVwZGF0ZWRPdXRjb21lc0hhc2hcbiAgICAgICAgfSxcbiAgICAgICAgYWxsT2JqZWN0aXZlc0FwcGxpZWQ6IHsgXG4gICAgICAgICAgJHNldDogYWN0aW9uLnBheWxvYWQuaXggPT09IHN0YXRlLm9iamVjdGl2ZXMubGVuZ3RoLTEgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG4iXX0=