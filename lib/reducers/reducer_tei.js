"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

var _immutabilityHelper = _interopRequireDefault(require("immutability-helper"));

var _index = require("../actions/index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EMBODIMENT = 'frbr:embodiment';
var ASSOCIATED = "http://example.com/must-revisit-these/associatedWith";
var MEMBER = 'rdfs:member';
var TEITYPE = 'meld:TEIEmbodiment';
var LIBRETTOTYPE = 'mo:PublishedLibretto';

function _default() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    TEI: {},
    componentTargets: {},
    fragImages: {},
    librettoTargets: {}
  };
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case _index.FETCH_TEI:
      return (0, _immutabilityHelper["default"])(state, {
        TEI: {
          $merge: _defineProperty({}, action.payload.uri, action.payload.data)
        }
      });

    case _index.FETCH_MANIFESTATIONS:
      // find associated TEI
      var target = action.payload.target;
      var part = action.payload.part;

      if (typeof part === "undefined") {
        // part wasn't on segment line
        return state;
      } // console.log("In FETCH_MANIFESTATIONS TEI, target is: ", target, " part is: ", part);


      var fragments = [];
      var libretto = []; // go through each part, finding embodibags

      if (EMBODIMENT in part) {
        if (!Array.isArray(part[EMBODIMENT])) {
          part[EMBODIMENT] = [part[EMBODIMENT]];
        }

        part[EMBODIMENT].map(function (embodiment) {
          // go through each embodiment
          if (MEMBER in embodiment) {
            // extract set of fragments
            if (!Array.isArray(embodiment["@type"])) {
              embodiment["@type"] = [embodiment["@type"]];
            }

            if (embodiment["@type"].includes(TEITYPE)) {
              if (!Array.isArray(embodiment[MEMBER])) {
                embodiment[MEMBER] = [embodiment[MEMBER]];
              }

              var TEIFrags = embodiment[MEMBER].map(function (member) {
                return member["@id"];
              });

              if (embodiment["@type"].includes(LIBRETTOTYPE)) {
                console.log("----------------------");
                libretto = libretto.concat(TEIFrags);
              }

              fragments = fragments.concat(TEIFrags);
            } else {
              console.log("TEI Reducer: Embodiment with unknown type", embodiment);
            } //fragments[fragtype] = embodiment[MEMBER].map( (member) => {

          } else {
            console.log("Embodiment without members: ", part, embodiment);
          }
        });
        return (0, _immutabilityHelper["default"])(state, {
          componentTargets: {
            $merge: _defineProperty({}, target["@id"], fragments)
          },
          librettoTargets: {
            $merge: _defineProperty({}, target["@id"], libretto)
          }
        });
      }
      /*
          if(ASSOCIATED in target) {
        if(!Array.isArray(target[ASSOCIATED])) {
          target[ASSOCIATED] = [target[ASSOCIATED]];
        }
              // extract target fragments
              // TODO properly ontologize ASSOCIATED, including differentiating TEI and others
              const fragments = target[ASSOCIATED].map( (assoc) => {
                  return assoc["@id"];
              });
              const targetid = target["@id"];
        // are there any associated images?
        const fragImages = {};
          target[ASSOCIATED].filter( (assoc) => {
          return EMBODIMENT in assoc
        }).map( (assoc) => {
          fragImages[assoc["@id"]] = assoc[EMBODIMENT]["@id"];
        })
              return update(state, {
          componentTargets: { $merge: { [target["@id"]]: fragments }},
          fragImages: { $merge: fragImages }
         });
          console.log("FETCH_COMPONENT_TARGET: Unassociated target! ", target);
          }*/


      return state;

    default:
      return state;
  }
}

;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9yZWR1Y2VyX3RlaS5qcyJdLCJuYW1lcyI6WyJFTUJPRElNRU5UIiwiQVNTT0NJQVRFRCIsIk1FTUJFUiIsIlRFSVRZUEUiLCJMSUJSRVRUT1RZUEUiLCJzdGF0ZSIsIlRFSSIsImNvbXBvbmVudFRhcmdldHMiLCJmcmFnSW1hZ2VzIiwibGlicmV0dG9UYXJnZXRzIiwiYWN0aW9uIiwidHlwZSIsIkZFVENIX1RFSSIsIiRtZXJnZSIsInBheWxvYWQiLCJ1cmkiLCJkYXRhIiwiRkVUQ0hfTUFOSUZFU1RBVElPTlMiLCJ0YXJnZXQiLCJwYXJ0IiwiZnJhZ21lbnRzIiwibGlicmV0dG8iLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJlbWJvZGltZW50IiwiaW5jbHVkZXMiLCJURUlGcmFncyIsIm1lbWJlciIsImNvbnNvbGUiLCJsb2ciLCJjb25jYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsVUFBVSxHQUFHLGlCQUFuQjtBQUNBLElBQU1DLFVBQVUsR0FBRyxzREFBbkI7QUFDQSxJQUFNQyxNQUFNLEdBQUcsYUFBZjtBQUNBLElBQU1DLE9BQU8sR0FBRyxvQkFBaEI7QUFDQSxJQUFNQyxZQUFZLEdBQUcsc0JBQXJCOztBQUVlLG9CQUFnRztBQUFBLE1BQXRGQyxLQUFzRix1RUFBOUU7QUFBQ0MsSUFBQUEsR0FBRyxFQUFFLEVBQU47QUFBVUMsSUFBQUEsZ0JBQWdCLEVBQUUsRUFBNUI7QUFBZ0NDLElBQUFBLFVBQVUsRUFBRSxFQUE1QztBQUFnREMsSUFBQUEsZUFBZSxFQUFFO0FBQWpFLEdBQThFO0FBQUEsTUFBUkMsTUFBUTs7QUFDN0csVUFBUUEsTUFBTSxDQUFDQyxJQUFmO0FBQ0UsU0FBS0MsZ0JBQUw7QUFDRSxhQUFPLG9DQUFPUCxLQUFQLEVBQWM7QUFBQ0MsUUFBQUEsR0FBRyxFQUFFO0FBQUNPLFVBQUFBLE1BQU0sc0JBQUlILE1BQU0sQ0FBQ0ksT0FBUCxDQUFlQyxH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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTSxhQUFPaEIsS0FBUDs7QUFDRjtBQUNFLGFBQU9BLEtBQVA7QUEvRUo7QUFrRkQ7O0FBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdXBkYXRlIGZyb20gJ2ltbXV0YWJpbGl0eS1oZWxwZXInO1xuaW1wb3J0IHtGRVRDSF9NQU5JRkVTVEFUSU9OUywgRkVUQ0hfVEVJfSBmcm9tICcuLi9hY3Rpb25zL2luZGV4J1xuXG5jb25zdCBFTUJPRElNRU5UID0gJ2ZyYnI6ZW1ib2RpbWVudCc7XG5jb25zdCBBU1NPQ0lBVEVEID0gXCJodHRwOi8vZXhhbXBsZS5jb20vbXVzdC1yZXZpc2l0LXRoZXNlL2Fzc29jaWF0ZWRXaXRoXCI7XG5jb25zdCBNRU1CRVIgPSAncmRmczptZW1iZXInO1xuY29uc3QgVEVJVFlQRSA9ICdtZWxkOlRFSUVtYm9kaW1lbnQnO1xuY29uc3QgTElCUkVUVE9UWVBFID0gJ21vOlB1Ymxpc2hlZExpYnJldHRvJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlID0ge1RFSToge30sIGNvbXBvbmVudFRhcmdldHM6IHt9LCBmcmFnSW1hZ2VzOiB7fSwgbGlicmV0dG9UYXJnZXRzOiB7fX0sIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBGRVRDSF9URUk6XG4gICAgICByZXR1cm4gdXBkYXRlKHN0YXRlLCB7VEVJOiB7JG1lcmdlOiB7W2FjdGlvbi5wYXlsb2FkLnVyaV06IGFjdGlvbi5wYXlsb2FkLmRhdGF9fX0pO1xuXG4gICAgY2FzZSBGRVRDSF9NQU5JRkVTVEFUSU9OUzpcbiAgICAgIC8vIGZpbmQgYXNzb2NpYXRlZCBURUlcbiAgICAgIGNvbnN0IHRhcmdldCA9IGFjdGlvbi5wYXlsb2FkLnRhcmdldDtcbiAgICAgIGNvbnN0IHBhcnQgPSBhY3Rpb24ucGF5bG9hZC5wYXJ0O1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIHBhcnQgd2Fzbid0IG9uIHNlZ21lbnQgbGluZVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIkluIEZFVENIX01BTklGRVNUQVRJT05TIFRFSSwgdGFyZ2V0IGlzOiBcIiwgdGFyZ2V0LCBcIiBwYXJ0IGlzOiBcIiwgcGFydCk7XG4gICAgICBsZXQgZnJhZ21lbnRzID0gW107XG4gICAgICBsZXQgbGlicmV0dG8gPSBbXTtcbiAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBwYXJ0LCBmaW5kaW5nIGVtYm9kaWJhZ3NcbiAgICAgIGlmIChFTUJPRElNRU5UIGluIHBhcnQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRbRU1CT0RJTUVOVF0pKSB7XG4gICAgICAgICAgcGFydFtFTUJPRElNRU5UXSA9IFtwYXJ0W0VNQk9ESU1FTlRdXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0W0VNQk9ESU1FTlRdLm1hcCgoZW1ib2RpbWVudCkgPT4ge1xuICAgICAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBlbWJvZGltZW50XG4gICAgICAgICAgaWYgKE1FTUJFUiBpbiBlbWJvZGltZW50KSB7XG4gICAgICAgICAgICAvLyBleHRyYWN0IHNldCBvZiBmcmFnbWVudHNcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbWJvZGltZW50W1wiQHR5cGVcIl0pKSB7XG4gICAgICAgICAgICAgIGVtYm9kaW1lbnRbXCJAdHlwZVwiXSA9IFtlbWJvZGltZW50W1wiQHR5cGVcIl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtYm9kaW1lbnRbXCJAdHlwZVwiXS5pbmNsdWRlcyhURUlUWVBFKSkge1xuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW1ib2RpbWVudFtNRU1CRVJdKSkge1xuICAgICAgICAgICAgICAgIGVtYm9kaW1lbnRbTUVNQkVSXSA9IFtlbWJvZGltZW50W01FTUJFUl1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBURUlGcmFncyA9IGVtYm9kaW1lbnRbTUVNQkVSXS5tYXAoKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJbXCJAaWRcIl07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoZW1ib2RpbWVudFtcIkB0eXBlXCJdLmluY2x1ZGVzKExJQlJFVFRPVFlQRSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgICAgICAgICAgbGlicmV0dG8gPSBsaWJyZXR0by5jb25jYXQoVEVJRnJhZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyYWdtZW50cyA9IGZyYWdtZW50cy5jb25jYXQoVEVJRnJhZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJURUkgUmVkdWNlcjogRW1ib2RpbWVudCB3aXRoIHVua25vd24gdHlwZVwiLCBlbWJvZGltZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZnJhZ21lbnRzW2ZyYWd0eXBlXSA9IGVtYm9kaW1lbnRbTUVNQkVSXS5tYXAoIChtZW1iZXIpID0+IHtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFbWJvZGltZW50IHdpdGhvdXQgbWVtYmVyczogXCIsIHBhcnQsIGVtYm9kaW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cGRhdGUoc3RhdGUsIHtcbiAgICAgICAgICBjb21wb25lbnRUYXJnZXRzOiB7JG1lcmdlOiB7W3RhcmdldFtcIkBpZFwiXV06IGZyYWdtZW50c319LFxuICAgICAgICAgIGxpYnJldHRvVGFyZ2V0czogeyRtZXJnZToge1t0YXJnZXRbXCJAaWRcIl1dOiBsaWJyZXR0b319XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICAgIGlmKEFTU09DSUFURUQgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHRhcmdldFtBU1NPQ0lBVEVEXSkpIHtcbiAgICAgICAgICB0YXJnZXRbQVNTT0NJQVRFRF0gPSBbdGFyZ2V0W0FTU09DSUFURURdXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleHRyYWN0IHRhcmdldCBmcmFnbWVudHNcbiAgICAgICAgICAgICAgLy8gVE9ETyBwcm9wZXJseSBvbnRvbG9naXplIEFTU09DSUFURUQsIGluY2x1ZGluZyBkaWZmZXJlbnRpYXRpbmcgVEVJIGFuZCBvdGhlcnNcbiAgICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGFyZ2V0W0FTU09DSUFURURdLm1hcCggKGFzc29jKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXNzb2NbXCJAaWRcIl07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRpZCA9IHRhcmdldFtcIkBpZFwiXTtcbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBhc3NvY2lhdGVkIGltYWdlcz9cbiAgICAgICAgY29uc3QgZnJhZ0ltYWdlcyA9IHt9O1xuICAgICAgICAgIHRhcmdldFtBU1NPQ0lBVEVEXS5maWx0ZXIoIChhc3NvYykgPT4ge1xuICAgICAgICAgIHJldHVybiBFTUJPRElNRU5UIGluIGFzc29jXG4gICAgICAgIH0pLm1hcCggKGFzc29jKSA9PiB7XG4gICAgICAgICAgZnJhZ0ltYWdlc1thc3NvY1tcIkBpZFwiXV0gPSBhc3NvY1tFTUJPRElNRU5UXVtcIkBpZFwiXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShzdGF0ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFRhcmdldHM6IHsgJG1lcmdlOiB7IFt0YXJnZXRbXCJAaWRcIl1dOiBmcmFnbWVudHMgfX0sXG4gICAgICAgICAgZnJhZ0ltYWdlczogeyAkbWVyZ2U6IGZyYWdJbWFnZXMgfVxuICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJGRVRDSF9DT01QT05FTlRfVEFSR0VUOiBVbmFzc29jaWF0ZWQgdGFyZ2V0ISBcIiwgdGFyZ2V0KTtcbiAgICAgICAgICB9Ki9cbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbn07XG4iXX0=